cat(">>> FOUND CANDIDATE MOTIF:", motif, "\n")
cat("    Position in Overlap (bp from start):", start(hits), "\n")
# Extract context (10bp before, Motif, 20bp after) to check for Stem-Loops
hit_start <- start(hits)
context_start <- max(1, hit_start - 10)
context_end <- min(width(biological_overlap), hit_start + 30)
context_seq <- subseq(biological_overlap, start=context_start, end=context_end)
cat("    Sequence Context:\n")
# Fancy printing to highlight the motif
prefix <- subseq(biological_overlap, start=context_start, end=hit_start-1)
suffix <- subseq(biological_overlap, start=hit_start+nchar(motif), end=context_end)
cat("    5'-", as.character(prefix), "[", motif, "]", as.character(suffix), "-3'\n\n")
cat("    [INTERPRETATION]:\n")
cat("    If this is the real site, the RNA likely forms a secondary structure\n")
cat("    (stem-loop or pseudoknot) in the 5-10 bases immediately following the bracket.\n\n")
}
}
if (!found_hit) {
cat("No canonical slippery motifs found in the overlap region.\n")
cat("This suggests the frameshift might be non-canonical or the overlap is smaller than predicted.\n")
}
# --- 1. Load Required Package ---
if (!requireNamespace("Biostrings", quietly = TRUE)) {
install.packages("BiocManager")
BiocManager::install("Biostrings")
}
library(Biostrings)
# --- 2. Download Reference Sequences from UniProt ---
cat("Downloading reference sequences for Southern cowpea mosaic virus...\n")
# P21405: Replicase Polyprotein (Contains Protease, VPg, RdRp)
ref_polyprotein <- readAAStringSet("https://rest.uniprot.org/uniprotkb/P21405.fasta")
names(ref_polyprotein) <- "SCPMV_Replicase_P2AB_Ref"
# P03607: Coat Protein
ref_coat <- readAAStringSet("https://rest.uniprot.org/uniprotkb/P03607.fasta")
names(ref_coat) <- "SCPMV_Coat_Ref"
# --- 3. Save to Files for Alignment ---
writeXStringSet(ref_polyprotein, "SCPMV_P2AB_Ref.fasta")
writeXStringSet(ref_coat, "SCPMV_Coat_Ref.fasta")
cat("Success! Files saved:\n")
cat("1. SCPMV_P2AB_Ref.fasta (Use to map ORF12/ORF20)\n")
cat("2. SCPMV_Coat_Ref.fasta (Use to map ORF14)\n")
# --- 4. Print Cleavage Site Info (Guide for your Analysis) ---
cat("\n[GUIDE] Known Cleavage Sites in this Reference (SCPMV):\n")
cat("-------------------------------------------------------\n")
cat("Protease / VPg Boundary:  Between residue 325 (Glu) and 326 (Thr)\n")
cat("VPg / RdRp Boundary:      Between residue 402 (Glu) and 403 (Thr)\n")
cat("-------------------------------------------------------\n")
cat("Look for similar 'Glu-Thr' (E-T) or 'Glu-Ser' (E-S) motifs in your alignment!\n")
# --- 1. Load Required Package ---
if (!requireNamespace("Biostrings", quietly = TRUE)) {
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Biostrings")
}
library(Biostrings)
# --- 2. Setup: Load File ---
file_path <- "/Users/lileenei/Downloads/SRR166857xx.rdrp.fa"
rdrp_sequences <- readDNAStringSet(file_path)
# Find the longest contig (SRR16685780_NODE_1)
longest_index <- which.max(width(rdrp_sequences))
main_contig <- rdrp_sequences[[longest_index]] # This is a DNAString object
main_name <- names(rdrp_sequences)[longest_index]
# FIX: Use length() for a single DNAString, not width()
main_length <- length(main_contig)
edge_size <- 150 # Search for 150 bp overlaps
cat("Target Contig:", main_name, "\n")
cat("Length:", main_length, "bp\n")
cat("Searching for overlaps to extend the Biological 5' End (ORF1 side)...\n")
# --- 3. Define the "Edge" to search for ---
# Since your contig is the MINUS strand:
# The end of the sequence string (High Coordinates) is the Biological 5' End.
# We want to find a new contig that contains this edge sequence.
start_pos_5prime <- main_length - edge_size + 1
end_pos_5prime <- main_length
# Extract the last 150bp of the contig
end_edge <- subseq(main_contig, start=start_pos_5prime, end=end_pos_5prime)
# --- 4. Search for overlaps in all other sequences ---
found_extension <- FALSE
for (i in 1:length(rdrp_sequences)) {
if (i == longest_index) next # Skip the main contig itself
candidate <- rdrp_sequences[[i]]
# FIX: Use length() for the candidate DNAString
candidate_len <- length(candidate)
if (candidate_len < edge_size) next # Skip sequences shorter than the edge
# Search Strategy:
# The candidate might be in the Plus or Minus orientation.
# We search for our 'end_edge' (or its reverse complement) inside the candidate.
# 1. Check Exact Match (Candidate is also Minus strand)
hits_raw <- matchPattern(end_edge, candidate, max.mismatch=2)
# 2. Check Reverse Complement Match (Candidate is Plus strand)
rc_end_edge <- reverseComplement(end_edge)
hits_rc <- matchPattern(rc_end_edge, candidate, max.mismatch=2)
if (length(hits_raw) > 0 || length(hits_rc) > 0) {
found_extension <- TRUE
cat("\n>>> POTENTIAL EXTENSION FOUND!\n")
cat("    Contig ID:", names(rdrp_sequences)[i], "\n")
cat("    Length:", candidate_len, "bp\n")
if (length(hits_raw) > 0) {
cat("    Orientation: Minus Strand (Same as Main)\n")
} else {
cat("    Orientation: Plus Strand (Reverse to Main)\n")
}
cat("    [ACTION]: You can assemble this contig with your main one to find ORF1.\n")
}
}
if (!found_extension) {
cat("\nNo overlaps found to extend the genome.\n")
cat("Your 3215 bp contig is likely the complete assembled unit available in this file.\n")
}
library(Biostrings)
library(archive)
# --- 1. Define URL and Filenames ---
logan_url <- "https://s3.amazonaws.com/logan-pub/c/SRR16685779/SRR16685779.contigs.fa.zst"
input_zst <- "SRR16685779.contigs.fa.zst"
# Use a temporary file for output to avoid permission errors
output_fa <- tempfile(fileext = ".fa")
# --- 2. Robust Download ---
cat("Attempting download...\n")
# Use method="libcurl" which is more robust for HTTPS
tryCatch({
download.file(logan_url, input_zst, mode = "wb", method = "libcurl")
}, error = function(e) {
# Fallback if libcurl fails
download.file(logan_url, input_zst, mode = "wb")
})
# --- 3. DIAGNOSTIC: Check if the file is real ---
file_size <- file.info(input_zst)$size
cat("Downloaded file size:", file_size, "bytes\n")
if (file_size < 1000) {
# If file is tiny, it's likely an AWS Error Message (XML)
cat("‚ö†Ô∏è WARNING: File is extremely small. Checking contents...\n")
first_line <- readLines(input_zst, n=1, warn=FALSE)
cat("First line of file:", first_line, "\n")
if (grepl("<Error>", first_line) || grepl("<?xml", first_line)) {
stop("STOPPING: The downloaded file is an AWS Error Page, not a ZST file.\nThe URL might be incorrect or the file doesn't exist on the server.")
}
}
# --- 4. Decompress using 'archive_read' stream ---
cat("File looks valid. Attempting decompression to temp folder...\n")
tryCatch({
# Open the ZST file as a stream
con_in <- archive_read(input_zst)
# Open the Output file (in temp folder)
con_out <- file(output_fa, "wb")
# Stream data in chunks
while(length(chunk <- readBin(con_in, raw(), n = 1024*1024)) > 0) {
writeBin(chunk, con_out)
}
close(con_in)
close(con_out)
cat("‚úÖ Success! Decompressed to:", output_fa, "\n")
# --- 5. Load the Sequences ---
cat("Loading sequences into R...\n")
all_contigs <- readDNAStringSet(output_fa)
cat("\n==========================================\n")
cat("Total Contigs Loaded:", length(all_contigs), "\n")
cat("Max Length:", max(width(all_contigs)), "bp\n")
cat("==========================================\n")
# --- 6. AUTO-RUN: Search for your Virus ---
probe_seq <- DNAString("ATGCCCCTCGTTGCGGTTGGAAGATCGGGT") # Start of ORF20
hits <- vmatchPattern(probe_seq, all_contigs)
if (sum(elementNROWS(hits)) > 0) {
idx <- which(elementNROWS(hits) > 0)[1]
my_contig <- all_contigs[[idx]]
cat(">>> FOUND YOUR VIRUS in this file!\n")
cat("    ID:", names(all_contigs)[idx], "\n")
cat("    Length:", length(my_contig), "bp\n")
if (length(my_contig) > 3215) {
cat("    üéâ RESULT: This contig is LONGER! You have the missing data.\n")
} else {
cat("    RESULT: Same length as before.\n")
}
} else {
cat("Could not find your specific virus sequence in this file.\n")
}
}, error = function(e) {
cat("\n‚ùå CRITICAL ERROR during decompression:\n")
cat(e$message, "\n")
cat("This confirms the file format is invalid or corrupt.\n")
})
library(Biostrings)
# --- 1. SETUP: Where are your files? ---
# UPDATE THIS PATH to the folder where you saved the .fa files
# Example (Windows): "C:/Users/Name/Downloads/MyContigs"
# Example (Mac/Linux): "/Users/Name/Downloads/MyContigs"
folder_path <- "/Users/lileenei/Downloads/E-SRR files"
# --- 2. Load and Combine All Files ---
cat("Scanning folder for .fa files...\n")
file_list <- list.files(path = folder_path, pattern = "\\.fa$|\\.fasta$", full.names = TRUE)
if (length(file_list) == 0) {
stop("No .fa or .fasta files found in that folder! Check the path.")
}
cat("Found", length(file_list), "files. Loading them now...\n")
# Read all files and combine them into one massive DNAStringSet
all_contigs <- do.call(c, lapply(file_list, readDNAStringSet))
cat("==========================================\n")
cat("SUCCESS! Combined Meta-Dataset Loaded.\n")
cat("Total Sequences:", length(all_contigs), "\n")
cat("==========================================\n")
# --- 3. DEFINE YOUR VIRUS (The 3215 bp Anchor) ---
# We use the start of your known RdRp (ORF20) as the search probe
probe_seq <- DNAString("ATGCCCCTCGTTGCGGTTGGAAGATCGGGT")
cat("\nFinding your main virus contig in the pile...\n")
hits <- vmatchPattern(probe_seq, all_contigs)
if (sum(elementNROWS(hits)) == 0) {
stop("Your virus was not found in these files! Are you sure they are the right datasets?")
}
# Find the longest version of your virus in this new dataset
match_indices <- which(elementNROWS(hits) > 0)
candidates <- all_contigs[match_indices]
best_idx <- which.max(width(candidates))
main_contig <- candidates[[best_idx]]
main_length <- length(main_contig)
cat(">>> FOUND YOUR VIRUS!\n")
cat("    Best Contig ID:", names(candidates)[best_idx], "\n")
cat("    Length:", main_length, "bp\n")
if (main_length > 3215) {
cat("    üéâ RESULT: You found a LONGER assembly! Use this for your final genome.\n")
# Save it immediately
writeXStringSet(DNAStringSet(main_contig), "Extended_Genome_Found.fasta")
} else {
cat("    RESULT: Matches your current 3215 bp length.\n")
}
# --- 4. THE EXTENSION HUNT (Bridging the Gap) ---
# Now we search EVERY sequences to see if any overlap the 5' tip of your virus
cat("\nScanning all", length(all_contigs), "sequences for overlaps...\n")
edge_size <- 150
# Minus Strand Logic: Biological 5' end is at the END of the sequence
start_pos <- main_length - edge_size + 1
end_edge <- subseq(main_contig, start=start_pos, end=main_length)
found_extension <- FALSE
for (i in 1:length(all_contigs)) {
# Skip the virus itself
if (names(all_contigs)[i] == names(candidates)[best_idx]) next
candidate <- all_contigs[[i]]
if (length(candidate) < edge_size) next
# Search for the edge (Raw or Reverse Complement)
hits_raw <- matchPattern(end_edge, candidate, max.mismatch=2)
rc_edge <- reverseComplement(end_edge)
hits_rc <- matchPattern(rc_edge, candidate, max.mismatch=2)
if (length(hits_raw) > 0 || length(hits_rc) > 0) {
found_extension <- TRUE
cat("\n>>> EXTENSION CANDIDATE FOUND!\n")
cat("    ID:", names(all_contigs)[i], "\n")
cat("    Length:", length(candidate), "bp\n")
# Save it for you to check
out_name <- paste0("Extension_Candidate_", i, ".fasta")
writeXStringSet(candidate, out_name)
cat("    Saved to:", out_name, "\n")
}
}
library(Biostrings)
# --- 1. SETUP: Where are your files? ---
# UPDATE THIS PATH to the folder where you saved the .fa files
# Example (Windows): "C:/Users/Name/Downloads/MyContigs"
# Example (Mac/Linux): "/Users/Name/Downloads/MyContigs"
folder_path <- "/Users/lileenei/Downloads/E-SRR files"
# --- 2. Load and Combine All Files ---
cat("Scanning folder for .fa files...\n")
file_list <- list.files(path = folder_path, pattern = "\\.fa$|\\.fasta$", full.names = TRUE)
if (length(file_list) == 0) {
stop("No .fa or .fasta files found in that folder! Check the path.")
}
cat("Found", length(file_list), "files. Loading them now...\n")
# Read all files and combine them into one massive DNAStringSet
all_contigs <- do.call(c, lapply(file_list, readDNAStringSet))
cat("==========================================\n")
cat("SUCCESS! Combined Meta-Dataset Loaded.\n")
cat("Total Sequences:", length(all_contigs), "\n")
cat("==========================================\n")
# --- 3. DEFINE YOUR VIRUS (The 3215 bp Anchor) ---
# We use the start of your known RdRp (ORF20) as the search probe
probe_seq <- DNAString("ATGCCCCTCGTTGCGGTTGGAAGATCGGGT")
cat("\nFinding your main virus contig in the pile...\n")
hits <- vmatchPattern(probe_seq, all_contigs)
if (sum(elementNROWS(hits)) == 0) {
stop("Your virus was not found in these files! Are you sure they are the right datasets?")
}
# Find the longest version of your virus in this new dataset
match_indices <- which(elementNROWS(hits) > 0)
candidates <- all_contigs[match_indices]
best_idx <- which.max(width(candidates))
main_contig <- candidates[[best_idx]]
main_length <- length(main_contig)
cat(">>> FOUND YOUR VIRUS!\n")
cat("    Best Contig ID:", names(candidates)[best_idx], "\n")
cat("    Length:", main_length, "bp\n")
if (main_length > 3215) {
cat("    üéâ RESULT: You found a LONGER assembly! Use this for your final genome.\n")
# Save it immediately
writeXStringSet(DNAStringSet(main_contig), "Extended_Genome_Found.fasta")
} else {
cat("    RESULT: Matches your current 3215 bp length.\n")
}
# --- 4. THE EXTENSION HUNT (Bridging the Gap) ---
# Now we search EVERY sequences to see if any overlap the 5' tip of your virus
cat("\nScanning all", length(all_contigs), "sequences for overlaps...\n")
edge_size <- 150
# Minus Strand Logic: Biological 5' end is at the END of the sequence
start_pos <- main_length - edge_size + 1
end_edge <- subseq(main_contig, start=start_pos, end=main_length)
found_extension <- FALSE
for (i in 1:length(all_contigs)) {
# Skip the virus itself
if (names(all_contigs)[i] == names(candidates)[best_idx]) next
candidate <- all_contigs[[i]]
if (length(candidate) < edge_size) next
# Search for the edge (Raw or Reverse Complement)
hits_raw <- matchPattern(end_edge, candidate, max.mismatch=2)
rc_edge <- reverseComplement(end_edge)
hits_rc <- matchPattern(rc_edge, candidate, max.mismatch=2)
if (length(hits_raw) > 0 || length(hits_rc) > 0) {
found_extension <- TRUE
cat("\n>>> EXTENSION CANDIDATE FOUND!\n")
cat("    ID:", names(all_contigs)[i], "\n")
cat("    Length:", length(candidate), "bp\n")
# --- THE FIX IS HERE: Wrap candidate in DNAStringSet() ---
out_name <- paste0("Extension_Candidate_", i, ".fasta")
writeXStringSet(DNAStringSet(candidate), out_name)
cat("    Saved to:", out_name, "\n")
}
}
if (!found_extension) {
cat("\nNo valid extensions found in any of the files.\n")
cat("Conclusion: The 4000 bp sequence is the definitive limit of this assembly.\n")
}
library(Biostrings)
file_path <-"/Users/lileenei/Downloads/SRR166857xx.rdrp.fa"
rdrp_sequences <- readDNAStringSet(file_path)
#identify the longest contig
sequence_lengths <- width(rdrp_sequences)
longest_index <- which.max(sequence_lengths)
longest_contig_id <- names(rdrp_sequences)[longest_index]
longest_contig_seq <- rdrp_sequences[[longest_index]]
longest_contig_length <- sequence_lengths[longest_index]
#print the result
print(paste("Initial Candidate Length:", width(longest_contig_seq), "bp"))
library(Biostrings)
file_path <-"/Users/lileenei/Downloads/SRR166857xx.rdrp.fa"
rdrp_sequences <- readDNAStringSet(file_path)
#identify the longest contig
sequence_lengths <- width(rdrp_sequences)
longest_index <- which.max(sequence_lengths)
longest_contig_id <- names(rdrp_sequences)[longest_index]
longest_contig_seq <- rdrp_sequences[[longest_index]]
longest_contig_length <- sequence_lengths[longest_index]
#print the result
print(paste("Initial Candidate Length:", length(longest_contig_seq), "bp"))
# Result: ~3,215 bp
library(Biostrings)
file_path <-"/Users/lileenei/Downloads/SRR166857xx.rdrp.fa"
rdrp_sequences <- readDNAStringSet(file_path)
#identify the longest contig
sequence_lengths <- width(rdrp_sequences)
longest_index <- which.max(sequence_lengths)
longest_contig_id <- names(rdrp_sequences)[longest_index]
longest_contig_seq <- rdrp_sequences[[longest_index]]
longest_contig_length <- sequence_lengths[longest_index]
#print the result
print(paste("Initial Candidate Length:", length(longest_contig_seq), "bp"))
# Result: ~3,215 bp
seq_char <- as.character(longest_contig_seq)
print(paste("Sequence Start:", substr(seq_char, 1, 50), "..."))
library(Biostrings)
file_path <-"/Users/lileenei/Downloads/SRR166857xx.rdrp.fa"
rdrp_sequences <- readDNAStringSet(file_path)
#identify the longest contig
sequence_lengths <- width(rdrp_sequences)
longest_index <- which.max(sequence_lengths)
longest_contig_id <- names(rdrp_sequences)[longest_index]
longest_contig_seq <- rdrp_sequences[[longest_index]]
longest_contig_length <- sequence_lengths[longest_index]
#print the result
print(paste("Initial Candidate Length:", length(longest_contig_seq), "bp"))
# Result: ~3,215 bp
seq_char <- as.character(longest_contig_seq)
print(paste("Sequence Start:", substr(seq_char, 1, 3215), "..."))
library(Biostrings)
file_path <-"/Users/lileenei/Downloads/SRR166857xx.rdrp.fa"
rdrp_sequences <- readDNAStringSet(file_path)
#identify the longest contig
sequence_lengths <- width(rdrp_sequences)
longest_index <- which.max(sequence_lengths)
longest_contig_id <- names(rdrp_sequences)[longest_index]
longest_contig_seq <- rdrp_sequences[[longest_index]]
longest_contig_length <- sequence_lengths[longest_index]
#print the result
print(paste("Initial Candidate Length:", length(longest_contig_seq), "bp"))
# Result: ~3,215 bp
seq_char <- as.character(longest_contig_seq)
print(seq_char)
#2. SECONDARY SEARCH WITHIN LOGAN FILES TO OBTAIN FINAL 4015nt GENOME
#set up path to the decompressed logan files
folder_path <- "/Users/lileenei/Downloads/E-SRR files"
# load and combine all files inot one DNAStringSet
file_list <- list.files(path = folder_path, pattern = "\\.fa$|\\.fasta$", full.names = TRUE)
all_contigs <- do.call(c, lapply(file_list, readDNAStringSet))
#We use the N-terminus of the predicted RdRp within the 3215nt assembly
probe_seq <- DNAString("ATGCCCCTCGTTGCGGTTGGAAGATCGGGT")
#search for the virus in the full dataset
hits <- vmatchPattern(probe_seq, all_contigs)
candidates <- all_contigs[elementNROWS(hits) > 0]
#identify the longest assembly
longest_idx <- which.max(width(candidates))
final_genome <- candidates[[longest_idx]]
#results
print(paste("Final Genome Length:", length(final_genome), "nt"))
# Expected Result: 4,015 bp (Recovered from SRR16685781)
#final genome
final_char <- as.character(final_genome)
print(final_char)
#3. COVERAGE FROM DIFFERENT SAMPLES
# retrieve the full header names (which contain the coverage info)
hit_headers <- names(candidates)
# retrieve the lengths of all hits
hit_lengths <- width(candidates)
# create a summary table
coverage_data <- data.frame(
Sequence_Header = hit_headers,
Length = hit_lengths
)
# print
print("--- COMPARISON OF VIRAL HITS ---")
print(coverage_data)
# --- FULL DATA EXTRACTION ---
# 1. Get the raw headers from ALL matching contigs
raw_headers <- names(candidates)
# 2. Extract the Coverage (ka:f)
coverage_values <- as.numeric(sub(".*ka:f:([0-9.]+).*", "\\1", raw_headers))
# 3. Extract the SRR ID (Just the run name, to make it readable)
# This grabs the "SRRxxxxxxx" part from the filename
srr_ids <- sub(".*(SRR[0-9]+).*", "\\1", raw_headers)
# 4. Create the Master Table
full_results <- data.frame(
SRR_ID = srr_ids,
Length_nt = width(candidates),
Coverage = coverage_values
)
# 5. Sort by Length (Longest to Shortest) to see who has the best genome
full_results <- full_results[order(full_results$Length_nt, decreasing = TRUE), ]
# 6. Print the Full Table
print("--- ALL VIRAL HITS FOUND ---")
print(full_results)
# --- FULL DATA EXTRACTION WITH METADATA ---
# 1. Get the raw headers from ALL matching contigs
raw_headers <- names(candidates)
# 2. Extract the Coverage (ka:f)
coverage_values <- as.numeric(sub(".*ka:f:([0-9.]+).*", "\\1", raw_headers))
# 3. Extract the SRR ID
srr_ids <- sub(".*(SRR[0-9]+).*", "\\1", raw_headers)
# 4. Define the Metadata Mapping (Manual Lookup)
# We map the SRR IDs to their Tissue type based on the BioProject metadata
metadata_map <- c(
"SRR16685781" = "Intestine",
"SRR16685783" = "Intestine",
"SRR16685784" = "Intestine",
"SRR16685780" = "Feces",
"SRR16685779" = "Feces",
"SRR16685777" = "Feces"
)
# 5. Create the Master Table
full_results <- data.frame(
SRR_ID = srr_ids,
Sample_Type = metadata_map[srr_ids],  # Map the IDs to the types
Length_nt = width(candidates),
Coverage = coverage_values
)
# 6. Sort by Length (Longest to Shortest)
full_results <- full_results[order(full_results$Length_nt, decreasing = TRUE), ]
# 7. Print the Full Table
print("--- ALL VIRAL HITS FOUND ---")
print(full_results)
#3. RETRIEVE THE COVERAGE AND LENGTH FROM DIFFERENT SAMPLES
# 1. Get the raw headers from ALL matching contigs
raw_headers <- names(candidates)
# 2. Extract the Coverage (ka:f)
coverage_values <- as.numeric(sub(".*ka:f:([0-9.]+).*", "\\1", raw_headers))
# 3. Extract the SRR ID
srr_ids <- sub(".*(SRR[0-9]+).*", "\\1", raw_headers)
# 4. Define the Metadata Mapping (Manual Lookup)
# We map the SRR IDs to their Tissue type based on the BioProject metadata
metadata_map <- c(
"SRR16685781" = "Intestine",
"SRR16685783" = "Intestine",
"SRR16685784" = "Intestine",
"SRR16685780" = "Feces",
"SRR16685779" = "Feces",
"SRR16685777" = "Feces"
)
# 5. Create the Master Table
full_results <- data.frame(
SRR_ID = srr_ids,
Sample_Type = metadata_map[srr_ids],  # Map the IDs to the types
Length_nt = width(candidates),
Coverage = coverage_values
)
# 6. Sort by Length (Longest to Shortest)
full_results <- full_results[order(full_results$Length_nt, decreasing = TRUE), ]
# 7. Print the Full Table
print("--- ALL VIRAL HITS FOUND ---")
print(full_results)
knitr::include_graphics("images/Table1.png")
knitr::include_graphics("images/Table1.png")
knitr::include_graphics("images/Table1.png")
knitr::include_graphics("images/Table1.png")
knitr::include_graphics("images/Table1.png")
knitr::include_graphics("images/Table1.png")
knitr::include_graphics("images/Figure1.png")
knitr::include_graphics("images/Figure2.png")
knitr::include_graphics("images/Figure3.png")
knitr::include_graphics("images/Figure4.png")
knitr::include_graphics("images/tweet.png")
